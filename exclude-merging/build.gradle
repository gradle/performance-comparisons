import org.gradle.util.GradleVersion

buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath "com.netflix.nebula:gradle-resolution-rules-plugin:2.0.0"
    }
}

boolean useExcludes = !project.hasProperty('noExcludes')
boolean useRules = project.hasProperty('useRules')
boolean isAtLeastGradle49 = GradleVersion.current().baseVersion.compareTo(GradleVersion.version('4.9')) >= 0
boolean useSupplier = project.findProperty('useSupplier') && project.getProperty('useSupplier')
boolean useLister = project.findProperty('useLister') && project.getProperty('useLister')
Class<?> supplierClass = useSupplier ? Class.forName(project.getProperty('useSupplier')) : null
Class<?> listerClass = useLister ? Class.forName(project.getProperty('useLister')) : null

allprojects {
    apply plugin: 'java'
    if (useExcludes) {
        apply plugin: 'nebula.resolution-rules'
    }
    repositories {
        def httpPort = project.hasProperty('httpPort') ? project.findProperty('httpPort') : '8000'
        def repositoryBase = project.hasProperty("useHttp") ? "http://localhost:${httpPort}" : "${rootProject.projectDir}/repository"
        ivy {
            url "$repositoryBase/ivy"
            if (useSupplier) {
                println "Using custom metadata supplier on Ivy repo: ${supplierClass}"
                setMetadataSupplier(supplierClass) {
                    params(false)
                }
            }
            if (useLister && isAtLeastGradle49) {
                println "Using custom version lister on Ivy repo: ${listerClass}"
                setComponentVersionsLister(listerClass) {
                    params(false)
                }
            }
        }
        maven {
            url "$repositoryBase/maven"
            if (useSupplier && isAtLeastGradle49) {
                println "Using custom metadata supplier on Maven repo: ${supplierClass}"
                setMetadataSupplier(supplierClass) {
                    params(true)
                }
            }
            if (useLister && isAtLeastGradle49) {
                println "Using custom version lister on Maven repo: ${listerClass}"
                setComponentVersionsLister(listerClass) {
                    params(true)
                }
            }
        }
        flatDir {
            dirs rootProject.file('rules')
        }
    }

    if (useExcludes) {
        apply plugin: 'nebula.resolution-rules'
    }

    configurations {
        simpletest
    }

    dependencies {
        if (useExcludes) {
            resolutionRules name: 'gradle-resolution-rules-0.28.0'
            resolutionRules name: 'resolution-rules-0.12.0'
        }

        simpletest('scott.black.hawk.down:character330:latest.release') { transitive = false }

        components.all(rules.StatusRule)
    }

    if (rootProject.findProperty('refresh')) {
        println "Setting cache for dynamic versions to 0 second"
        configurations.all {
            resolutionStrategy.cacheDynamicVersionsFor 0, "seconds"
        }
    }
}

int i = 0

if (!useExcludes) {
    println "Not using excludes, nor dependency rules plugin"
}

allprojects {
    dependencies {
        modules {
            module('com.google.inject:guice-assistedinject') {
                replacedBy('com.google.inject.extensions:guice-assistedinject')
            }
            module('com.google.inject:guice-throwingproviders') {
                replacedBy('com.google.inject.extensions:guice-throwingproviders')
            }
            module('scott.black.hawk.down:json') {
                replacedBy('org.json:json')
            }
        }
    }

    if (useExcludes) {
        def gid = ['foo', 'bar', 'baz']
        def aid = ['x', 'y', 'z', 'k', 't', 'u']
        // manage all exclusions in one place
        if (useRules) {
            dependencies {
                components {
                    all(rules.ExcludeCachableRule)
                }
            }
        } else {
            dependencies {
                components {
                    all(rules.ExcludeRule)
                }
            }
        }
    }
}

subprojects {
    // unlocked dependencies
    ext.dependencyReleaseStatus = System.getProperty('dependencyReleaseStatus', project.hasProperty("dependencyReleaseStatus") ? dependencyReleaseStatus : 'release')
    apply from: "dependencies.gradle"
}

project(':api-trace-agent') {
    dependencies {
        //compile project(':api-trace-common')
    }
}

project(':api') {
    dependencies {
        compile project(':api-service-layer-run')
        compile project(':api-groovy-extensions')
        compile project(':api-trace-agent')
        compile project(':api-dependencies')
    }
}

project(':api-test') {
    dependencies {
        compile project(':api-service-layer-endpoints')
        compile project(':api-service-layer')
    }
}

project(':api-service-layer') {
    dependencies {
        compile project(':api-service-layer-endpoints')
        //compile project(':api-trace-common')
    }
}

project(':api-service-layer-impl') {
    dependencies {
        compile project(':api-test')
        compile project(':api-service-layer')
        testCompile project(':api-service-layer-run')
        compile project(':api-dependencies')
        //compile project(':api-trace-common')
    }
}

project(':api-service-layer-run') {
    dependencies {
        compile project(':api-service-layer-endpoints')
        compile project(':api-dependencies')
    }
}

project(':api-dependencies') {
    dependencies {
        compile project(':api-test')
        compile project(':api-service-layer')
        compile project(':api-platform')
        compile project(':api-service-layer-endpoints')
    }
}

project(':api-service-layer-endpoints') {
    dependencies {
        compile project(':api-platform')
    }
}

project(':api-platform') {
    dependencies {
    }
}

allprojects {
    task resolveDependencies {
        doLast {
            def configs = project.findProperty('confs') ? project.getProperty('confs').split(',') : ['compile', 'testCompile', 'runtime', 'testRuntime']
            configs.each {
                configurations."$it".files
            }
        }
    }
}

def hashing = gradle.class.classLoader.loadClass('com.google.common.hash.Hashing')

task updateIvyStatus {
    ext.outputFile = file('repository/ivy/versions.txt')
    ext.outputFileSignature = file('repository/ivy/versions.txt.sha1')
    inputs.dir('repository/ivy')
    outputs.dir('repository/ivy')
    doLast {
        if (ext.outputFile.exists()) {
            ext.outputFile.delete()
        }
        ext.outputFile.withWriter { writer ->
            file('repository/ivy').eachFile { groupFile ->
                def group = groupFile.name
                if (groupFile.directory) {
                    groupFile.eachFile { moduleFile ->
                        def module = moduleFile.name
                        new File(moduleFile, 'versions.txt').withWriter { perVersion ->
                            moduleFile.eachFile { versionFile ->
                                if (versionFile.directory) {
                                    def version = versionFile.name
                                    def versionIvy = new File(versionFile, "ivy-${version}.xml")
                                    if (versionIvy.exists()) {
                                        def p = versionIvy.text =~ /status="(.+?)"/
                                        if (p.find()) {
                                            writer.writeLine "$group:$module:$version;${p.group(1)}"
                                            perVersion.writeLine "$group:$module:$version;${p.group(1)}"
                                        }
                                    }
                                }
                            }
                        }
                        def md = hashing.sha1()
                        new File(moduleFile, 'versions.txt.sha1').text = md.hashBytes(new File(moduleFile, 'versions.txt').bytes).toString()
                    }
                }
            }
        }
        ext.outputFileSignature.withWriter { writer ->
            def md = hashing.sha1()
            writer << md.hashBytes(ext.outputFile.bytes).toString()
        }
    }
}

task updateMavenStatus {
    ext.outputFile = file('repository/maven/versions.txt')
    ext.outputFileSignature = file('repository/maven/versions.txt.sha1')
    inputs.dir('repository/maven')
    outputs.dir('repository/maven')
    doLast {
        if (ext.outputFile.exists()) {
            ext.outputFile.delete()
        }
        ext.outputFile.withWriter { writer ->
            visitMavenRepo([], file('repository/maven'), writer)
        }
        ext.outputFileSignature.withWriter { writer ->
            def md = hashing.sha1()
            writer << md.hashBytes(ext.outputFile.bytes).toString()
        }
    }
}

private void visitMavenRepo(List<String> path, File currentDir, Writer singleVersionFileWriter) {
    File mavenMetadata = new File(currentDir, 'maven-metadata.xml')
    if (currentDir.directory) {
        if (mavenMetadata.exists() || looksLikeVersionDir(currentDir)) {
            // this is a directory of versions, and the name corresponds to an artifact id
            visitListOfVersions(path, currentDir, singleVersionFileWriter)
        } else {
            currentDir.eachFile {
                if (it.directory) {
                    visitMavenRepo(path + it.name, it, singleVersionFileWriter)
                }
            }
        }
    }
}

private boolean looksLikeVersionDir(File currentDir) {
    def files = currentDir.listFiles()
    for (int i = 0; i < files.length; i++) {
        if (files[i].directory) {
            if (files[i].listFiles().any { it.name.endsWith('.pom') }) {
                return true
            }
        }
    }
    return false
}

private void visitListOfVersions(List<String> path, File artifactDirectory, Writer singleVersionFileWriter) {
    def hashing = gradle.class.classLoader.loadClass('com.google.common.hash.Hashing')
    String group = path[0..<path.size() - 1].join('.')
    String artifactId = artifactDirectory.name
    def versionsFile = new File(artifactDirectory, 'versions.txt')
    versionsFile.withWriter { perModule ->
        artifactDirectory.listFiles().each {
            if (it.directory) {
                String version = it.name
                String status = version.endsWith('-SNAPSHOT') ? 'integration' : 'release'
                singleVersionFileWriter.writeLine "$group:$artifactId:$version;$status"
                perModule.writeLine "$group:$artifactId:$version;$status"
            }
        }
    }
    new File(artifactDirectory, 'versions.txt.sha1').text = hashing.sha1().hashBytes(versionsFile.bytes).toString()
}
